"use client"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card"
import { Textarea } from "@/components/ui/textarea"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Copy, Download, FileText, Link } from "lucide-react"
import { useToast } from "@/hooks/use-toast"
import { Toaster } from "@/components/ui/toaster"

export default function WechatToMarkdown() {
  const [inputUrl, setInputUrl] = useState("")
  const [inputHtml, setInputHtml] = useState("")
  const [markdown, setMarkdown] = useState("")
  const [isLoading, setIsLoading] = useState(false)
  const { toast } = useToast()

  // Â∞ÜHTMLËΩ¨Êç¢‰∏∫Markdown
  const htmlToMarkdown = (html: string): string => {
    let markdown = html;

    // 1. Pre-processing: Handle WeChat multimedia components FIRST (before any cleanup)
    // Extract and replace audio components
    let audioMatches = html.match(/<mp-common-mpaudio[^>]*>/gi);
    if (audioMatches) {
      audioMatches.forEach(match => {
        const nameMatch = match.match(/name=["']([^"']+)["']/i);
        const lengthMatch = match.match(/play_length=["']([^"']+)["']/i);
        const durationMatch = match.match(/duration=["']([^"']+)["']/i);
        
        let name = nameMatch ? nameMatch[1] : 'Èü≥È¢ë';
        let duration = '';
        
        // Handle different duration formats
        if (lengthMatch) {
          const lengthValue = lengthMatch[1];
          // Convert milliseconds to time format if needed
          if (lengthValue.match(/^\d+$/)) {
            const seconds = Math.floor(parseInt(lengthValue) / 1000);
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            duration = `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
          } else {
            duration = lengthValue;
          }
        } else if (durationMatch) {
          duration = durationMatch[1];
        }
        
        // Clean up technical names
        if (name === 'insertaudio' || name.includes('plugin')) {
          name = 'Èü≥È¢ëÂÜÖÂÆπ';
        }
        
        const replacement = duration ? 
          `\n\nüéµ **Èü≥È¢ë**Ôºö${name} (${duration})\n\n> ‚ö†Ô∏è Ê≥®ÊÑèÔºöÂæÆ‰ø°Èü≥È¢ëÊó†Ê≥ïÂú®Markdown‰∏≠Êí≠ÊîæÔºåÈúÄË¶ÅÂú®ÂéüÊñá‰∏≠Êî∂Âê¨\n\n` : 
          `\n\nüéµ **Èü≥È¢ë**Ôºö${name}\n\n> ‚ö†Ô∏è Ê≥®ÊÑèÔºöÂæÆ‰ø°Èü≥È¢ëÊó†Ê≥ïÂú®Markdown‰∏≠Êí≠ÊîæÔºåÈúÄË¶ÅÂú®ÂéüÊñá‰∏≠Êî∂Âê¨\n\n`;
        markdown = markdown.replace(match, replacement);
      });
    } else {
      // Fallback: look for any mention of mp-common-mpaudio
      if (html.includes('mp-common-mpaudio')) {
        markdown = markdown.replace(/mp-common-mpaudio[^>]*>/gi, '\n\nüéµ **Ê£ÄÊµãÂà∞Èü≥È¢ëÁªÑ‰ª∂**\n\n');
      }
    }
    
    // Extract and replace video components
    let videoMatches = html.match(/<iframe[^>]*src=["'][^"']*v\.qq\.com[^"']*["'][^>]*>/gi);
    if (videoMatches) {
      videoMatches.forEach(match => {
        const srcMatch = match.match(/src=["']([^"']+)["']/i);
        const vidMatch = match.match(/vid=([^&"']+)/i);
        const src = srcMatch ? srcMatch[1] : '';
        const videoId = vidMatch ? vidMatch[1] : '';
        
        const videoInfo = videoId ? 
          `\n\nüìπ **ËÖæËÆØËßÜÈ¢ë**Ôºö${videoId}\n\n[üîó ÁÇπÂáªÊí≠ÊîæËßÜÈ¢ë](${src})\n\n> üí° ÊèêÁ§∫ÔºöÁÇπÂáª‰∏äÊñπÈìæÊé•Âú®ÊµèËßàÂô®‰∏≠Êí≠ÊîæËßÜÈ¢ë\n\n` :
          `\n\nüìπ **ËßÜÈ¢ë**\n\n[üîó ÁÇπÂáªÊí≠ÊîæËßÜÈ¢ë](${src})\n\n> üí° ÊèêÁ§∫ÔºöÁÇπÂáª‰∏äÊñπÈìæÊé•Âú®ÊµèËßàÂô®‰∏≠Êí≠ÊîæËßÜÈ¢ë\n\n`;
        
        markdown = markdown.replace(match, videoInfo);
      });
    }
    
    // Handle video containers
    markdown = markdown.replace(/<span[^>]*class="js_tx_video_container"[^>]*>.*?<\/span>/gi, '\n\nüìπ **ËßÜÈ¢ëÊí≠ÊîæÂô®**\n\n');
    
    // Remove any remaining multimedia tags
    markdown = markdown.replace(/<\/?mp-common-mpaudio[^>]*>/gi, '');
    markdown = markdown.replace(/ÁÇπÂáªËæπÊ°ÜË∞ÉÂá∫ËßÜÈ¢ëÂ∑•ÂÖ∑Êù°/gi, '');

    // 1.5. Sanitization
    // Remove script and style tags completely
    markdown = markdown.replace(/<script[^>]*>.*?<\/script>/gis, "");
    markdown = markdown.replace(/<style[^>]*>.*?<\/style>/gis, "");
    // Remove unwanted attributes (but keep some for multimedia detection)
    markdown = markdown.replace(/\s(style|id)="[^"]*"/gi, "");

    // Additional iframe handling (fallback)
    markdown = markdown.replace(
      /<iframe[^>]*src=["']([^"']+)["'][^>]*><\/iframe>/gi,
      '\n\nüìπ **ËßÜÈ¢ë**Ôºö$1\n\n'
    );

    // Handle WeChat profile components
    markdown = markdown.replace(
      /<mp-common-profile[^>]*data-nickname=["']([^"']+)["'][^>]*>/gi,
      '\n\nüë§ **ÂæÆ‰ø°Âè∑**Ôºö$1\n\n'
    );

    // Remove decorative elements (dots, spans used for styling)
    markdown = markdown.replace(
      /<span[^>]*width:\s*\d+px[^>]*height:\s*\d+px[^>]*border-radius:\s*50%[^>]*><\/span>/gi,
      ''
    );

    // Handle WeChat layout containers and remove empty containers
    markdown = markdown.replace(/<section[^>]*powered-by="xiumi\.us"[^>]*><\/section>/gi, "");
    markdown = markdown.replace(/<section[^>]*><svg[^>]*><\/svg><\/section>/gi, "");
    
    // Handle text decoration spans (underline, strikethrough)
    markdown = markdown.replace(/<span[^>]*text-decoration:\s*underline[^>]*>(.*?)<\/span>/gi, "$1");
    markdown = markdown.replace(/<span[^>]*text-decoration:\s*line-through[^>]*>(.*?)<\/span>/gi, "~~$1~~");
    
    // Clean up excessive nesting in WeChat articles
    markdown = markdown.replace(/<p[^>]*><span[^>]*><span[^>]*>(.*?)<\/span><\/span><\/p>/gi, "$1\n\n");

    // 2. Structural Tag Conversion (Normalize common container tags)
    // Handle complex nested sections with inline-block layout
    markdown = markdown.replace(
      /<section[^>]*display:\s*inline-block[^>]*width:\s*\d+%[^>]*>(.*?)<\/section>/gis,
      '$1\n\n'
    );
    
    // Convert divs and sections used for structure into paragraphs
    markdown = markdown.replace(/<(div|section)[^>]*>/gi, "<p>");
    markdown = markdown.replace(/<\/(div|section)>/gi, "</p>");

    // 3. Block-Level Element Conversion
    // Headings (h1-h6) - Preserve inner formatting by converting it later
    markdown = markdown.replace(/<h([1-6])[^>]*>(.*?)<\/h[1-6]>/gi, (match, level, content) => {
      return "\n\n" + "#".repeat(Number.parseInt(level)) + " " + content.trim() + "\n\n";
    });

    // Paragraphs - Ensure they are separated by newlines
    markdown = markdown.replace(/<p[^>]*>(.*?)<\/p>/gis, (match, content) => {
      // Only add newlines if the paragraph is not empty
      return content.trim() ? "\n\n" + content.trim() + "\n\n" : "";
    });

    // Blockquotes
    markdown = markdown.replace(/<blockquote[^>]*>(.*?)<\/blockquote>/gis, (match, content) => {
        // Process each line inside the blockquote
        const lines = content.trim().split('\n');
        return "\n\n" + lines.map(line => `> ${line}`).join('\n') + "\n\n";
    });

    // Unordered Lists
    markdown = markdown.replace(/<ul[^>]*>(.*?)<\/ul>/gis, (match, content) => {
        const items = content.replace(/<li[^>]*>(.*?)<\/li>/gis, (liMatch, liContent) => {
            return `\n- ${liContent.trim()}`;
        });
        return items + "\n\n";
    });

    // Ordered Lists
    markdown = markdown.replace(/<ol[^>]*>(.*?)<\/ol>/gis, (match, content) => {
        let counter = 1;
        const items = content.replace(/<li[^>]*>(.*?)<\/li>/gis, (liMatch, liContent) => {
            return `\n${counter++}. ${liContent.trim()}`;
        });
        return items + "\n\n";
    });

    // Code Blocks
    markdown = markdown.replace(/<pre[^>]*><code[^>]*>(.*?)<\/code><\/pre>/gis, (match, content) => {
      const cleanContent = content.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&");
      return "\n\n```\n" + cleanContent.trim() + "\n```\n\n";
    });
    
    // Tables
    markdown = markdown.replace(/<table[^>]*>(.*?)<\/table>/gis, (match, content) => {
      let tableMarkdown = "\n";
      const rows = content.match(/<tr[^>]*>(.*?)<\/tr>/gis) || [];
      rows.forEach((row, index) => {
        const cells = row.match(/<t[hd][^>]*>(.*?)<\/t[hd]>/gis) || [];
        const cellContents = cells.map(cell =>
          cell.replace(/<t[hd][^>]*>(.*?)<\/t[hd]>/i, "$1").trim()
        );
        tableMarkdown += "| " + cellContents.join(" | ") + " |\n";
        if (index === 0) {
          tableMarkdown += "| " + cellContents.map(() => "---").join(" | ") + " |\n";
        }
      });
      return tableMarkdown + "\n";
    });

    // Horizontal Rules
    markdown = markdown.replace(/<hr[^>]*>/gi, "\n\n---\n\n");
    
    // Line breaks
    markdown = markdown.replace(/<br\s*\/?>/gi, "\n");

    // 4. Inline Element Conversion (Done after blocks to preserve them)
    // Images with proxy
    markdown = markdown.replace(
      /<img[^>]*src=["']([^"']+)["'][^>]*(?:alt=["']([^"']*)["'])?[^>]*>/gi,
      (match, src, alt) => {
        if (src.includes("image.baidu.com")) {
          return `![${alt || ""}](${src})`;
        }
        const proxyUrl = `https://image.baidu.com/search/down?thumburl=${encodeURIComponent(src)}`;
        return `![${alt || ""}](${proxyUrl})`;
      },
    );

    // Links
    markdown = markdown.replace(/<a[^>]*href=["']([^"']+)["'][^>]*>(.*?)<\/a>/gi, "[$2]($1)");

    // Bold and Strong
    markdown = markdown.replace(/<(strong|b)[^>]*>(.*?)<\/(strong|b)>/gi, "**$2**");
    
    // Italic and Emphasis
    markdown = markdown.replace(/<(em|i)[^>]*>(.*?)<\/(em|i)>/gi, "*$2*");
    
    // Inline Code
    markdown = markdown.replace(/<code[^>]*>(.*?)<\/code>/gi, (match, content) => {
      return `\`${content.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&")}\``;
    });

    // 5. Final Cleanup
    // Remove any remaining HTML tags
    markdown = markdown.replace(/<[^>]+>/g, "");

    // Clean up WeChat-specific artifacts
    // Remove powered-by attributes and other WeChat artifacts
    markdown = markdown.replace(/powered-by="[^"]*"/gi, "");
    markdown = markdown.replace(/nodeleaf="[^"]*"/gi, "");
    markdown = markdown.replace(/leaf="[^"]*"/gi, "");
    
    // Remove excessive whitespace and empty lines from complex layouts
    markdown = markdown.replace(/^\s*$/gm, ""); // Remove empty lines
    markdown = markdown.replace(/\n\s*\n\s*\n/g, "\n\n"); // Collapse multiple newlines

    // Decode HTML entities
    const htmlEntities: { [key: string]: string } = {
      "&nbsp;": " ", "&lt;": "<", "&gt;": ">", "&amp;": "&", "&quot;": '"',
      "&#39;": "'", "&ldquo;": '"', "&rdquo;": '"', "&lsquo;": "'", "&rsquo;": "'",
      "&mdash;": "‚Äî", "&ndash;": "‚Äì", "&hellip;": "‚Ä¶", "&copy;": "¬©",
      "&reg;": "¬Æ", "&trade;": "‚Ñ¢",
    };
    Object.entries(htmlEntities).forEach(([entity, char]) => {
      markdown = markdown.replace(new RegExp(entity, "g"), char);
    });

    // Normalize whitespace
    // Replace multiple newlines with a maximum of two
    markdown = markdown.replace(/\n{3,}/g, "\n\n");
    // Trim leading/trailing whitespace from the entire string
    markdown = markdown.trim();

    // Post-processing: Clean up artifacts from complex WeChat layouts
    // Remove standalone symbols and decorative text
    markdown = markdown.replace(/^\s*[‚Ä¢¬∑‚ñ™‚ñ´‚ó¶‚Ä£‚ÅÉ]\s*$/gm, ""); // Remove bullet points on their own lines
    markdown = markdown.replace(/^\s*["""'']\s*$/gm, ""); // Remove standalone quotes
    markdown = markdown.replace(/^\s*[ÔΩû„Äú~]\s*$/gm, ""); // Remove decorative tildes
    
    // Clean up excessive asterisks and formatting artifacts
    // Remove standalone asterisks on their own lines
    markdown = markdown.replace(/^\s*\*+\s*$/gm, "");
    
    // Remove excessive asterisks in text (more than 4 consecutive)
    markdown = markdown.replace(/\*{5,}/g, "**");
    
    // Clean up malformed bold formatting
    markdown = markdown.replace(/\*\*\*\*([^*]+)\*\*\*\*/g, "**$1**");
    markdown = markdown.replace(/\*\*\*([^*]+)\*\*\*/g, "**$1**");
    
    // Remove asterisks that are just decorative (not formatting)
    // But preserve meaningful formatting like **text**
    markdown = markdown.replace(/\*{6,}/g, ""); // Remove 6+ consecutive asterisks
    
    // Clean up specific patterns from your example
    markdown = markdown.replace(/\*\*\*\*([^*\n]+)\*\*\*\*/g, "**$1**"); // ****text**** -> **text**
    markdown = markdown.replace(/\*\*([^*\n]*?)\*\*\*\*([^*\n]*?)\*\*\*\*([^*\n]*?)\*\*/g, "**$1$2$3**"); // Complex patterns
    
    // Clean up empty bold/italic tags
    markdown = markdown.replace(/\*\*\s*\*\*/g, "");
    markdown = markdown.replace(/\*\s*\*/g, "");
    
    // Handle the specific pattern from your example: **text****other****text**
    // Convert to proper bold formatting
    markdown = markdown.replace(/\*\*([^*]+?)\*\*\*\*([^*]+?)\*\*\*\*([^*]+?)\*\*/g, "**$1** **$2** **$3**");
    markdown = markdown.replace(/\*\*([^*]+?)\*\*\*\*([^*]+?)\*\*/g, "**$1** **$2**");
    
    // Remove standalone asterisks that are not part of markdown formatting
    markdown = markdown.replace(/^(\s*)\*+(\s*)$/gm, "$1$2");
    
    // Clean up patterns like "****" at the beginning of lines
    markdown = markdown.replace(/^\*{2,}/gm, "");
    
    // Final cleanup of excessive newlines
    markdown = markdown.replace(/\n{3,}/g, "\n\n");

    return markdown;
  }

  // ‰ªéURLËé∑ÂèñÊñáÁ´†ÂÜÖÂÆπ
  const fetchFromUrl = async () => {
    if (!inputUrl.trim()) {
      toast({
        title: "ÈîôËØØ",
        description: "ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÂæÆ‰ø°ÂÖ¨‰ºóÂè∑ÊñáÁ´†ÈìæÊé•",
        variant: "destructive",
      })
      return
    }

    if (!inputUrl.includes("mp.weixin.qq.com")) {
      toast({
        title: "ÈîôËØØ",
        description: "ËØ∑ËæìÂÖ•ÊúâÊïàÁöÑÂæÆ‰ø°ÂÖ¨‰ºóÂè∑ÊñáÁ´†ÈìæÊé•",
        variant: "destructive",
      })
      return
    }

    setIsLoading(true)
    try {
      const response = await fetch("/api/fetch-article", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ url: inputUrl }),
      })

      const data = await response.json()

      if (data.success) {
        // Ëá™Âä®ËΩ¨Êç¢Ëé∑ÂèñÂà∞ÁöÑÂÜÖÂÆπÔºåÂπ∂Ê∑ªÂä†ÂéüÊñáÈìæÊé•
        const result = htmlToMarkdown(data.content)
        const titleText = data.title ? `# ${data.title}\n\n` : ''
        const sourceLink = `> üìñ **ÂéüÊñáÈìæÊé•**Ôºö[ÁÇπÂáªÊü•ÁúãÂéüÊñá](${inputUrl})\n\n> üí° **ÊèêÁ§∫**ÔºöÈü≥È¢ë„ÄÅËßÜÈ¢ëÁ≠âÂ§öÂ™í‰ΩìÂÜÖÂÆπËØ∑Âú®ÂéüÊñá‰∏≠Êü•Áúã\n\n---\n\n`
        setMarkdown(titleText + sourceLink + result)
        toast({
          title: "ÊàêÂäü",
          description: `ÊñáÁ´†"${data.title}"Ëé∑ÂèñÂπ∂ËΩ¨Êç¢ÂÆåÊàêÔºÅ`,
        })
      } else {
        throw new Error(data.error)
      }
    } catch (error) {
      console.error("Ëé∑ÂèñÊñáÁ´†Â§±Ë¥•:", error)
      toast({
        title: "ÈîôËØØ",
        description: error instanceof Error ? error.message : "Ëé∑ÂèñÊñáÁ´†ÂÜÖÂÆπÂ§±Ë¥•ÔºåËØ∑Â∞ùËØïÊâãÂä®Â§çÂà∂HTMLÂÜÖÂÆπ",
        variant: "destructive",
      })
    } finally {
      setIsLoading(false)
    }
  }

  // ËΩ¨Êç¢HTMLÂÜÖÂÆπ
  const convertHtml = () => {
    if (!inputHtml.trim()) {
      toast({
        title: "ÈîôËØØ",
        description: "ËØ∑ËæìÂÖ•HTMLÂÜÖÂÆπ",
        variant: "destructive",
      })
      return
    }

    setIsLoading(true)
    try {
      const result = htmlToMarkdown(inputHtml)
      const sourceHint = `> üí° **ÊèêÁ§∫**ÔºöÂ¶ÇÈúÄÊ∑ªÂä†ÂéüÊñáÈìæÊé•ÔºåËØ∑ÊâãÂä®ÁºñËæëMarkdownÂÜÖÂÆπ\n\n> üìù **Ê†ºÂºè**Ôºö\`> üìñ **ÂéüÊñáÈìæÊé•**Ôºö[ÁÇπÂáªÊü•ÁúãÂéüÊñá](ÂéüÊñáURL)\`\n\n---\n\n`
      setMarkdown(sourceHint + result)
      toast({
        title: "ÊàêÂäü",
        description: "ËΩ¨Êç¢ÂÆåÊàêÔºÅ",
      })
    } catch (error) {
      toast({
        title: "ÈîôËØØ",
        description: "ËΩ¨Êç¢Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•HTMLÊ†ºÂºè",
        variant: "destructive",
      })
    } finally {
      setIsLoading(false)
    }
  }

  // Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø
  const copyToClipboard = async () => {
    try {
      await navigator.clipboard.writeText(markdown)
      toast({
        title: "ÊàêÂäü",
        description: "Â∑≤Â§çÂà∂Âà∞Ââ™Ë¥¥Êùø",
      })
    } catch (error) {
      toast({
        title: "ÈîôËØØ",
        description: "Â§çÂà∂Â§±Ë¥•",
        variant: "destructive",
      })
    }
  }

  // ‰∏ãËΩΩMarkdownÊñá‰ª∂
  const downloadMarkdown = () => {
    const blob = new Blob([markdown], { type: "text/markdown" })
    const url = URL.createObjectURL(blob)
    const a = document.createElement("a")
    a.href = url
    a.download = "article.md"
    document.body.appendChild(a)
    a.click()
    document.body.removeChild(a)
    URL.revokeObjectURL(url)

    toast({
      title: "ÊàêÂäü",
      description: "Êñá‰ª∂‰∏ãËΩΩÂ∑≤ÂºÄÂßã",
    })
  }

  return (
    <div className="min-h-screen bg-background p-4">
      <div className="max-w-6xl mx-auto space-y-6">
        {/* Ê†áÈ¢ò */}
        <div className="text-center space-y-4">
          <div className="flex items-center justify-center gap-4">
            <a 
              href="https://github.com/1143520/wechat-markdown" 
              target="_blank" 
              rel="noopener noreferrer"
              className="hover:opacity-80 transition-opacity"
            >
              <img 
                src="https://jsd.chatbtc.cn.eu.org/gh/manji1143/picx-images-hosting@master/paste/picx-%E6%B0%B4%E5%A2%A8%E7%94%BB-logo-%E8%AE%BE%E8%AE%A1.41ye3jxic1.webp" 
                alt="ÂæÆ‰ø°ËΩ¨Markdown Logo" 
                className="w-16 h-16 object-contain"
              />
            </a>
          <h1 className="text-3xl font-bold text-foreground">ÂæÆ‰ø°ÂÖ¨‰ºóÂè∑ÊñáÁ´†ËΩ¨Markdown</h1>
          </div>
          <p className="text-muted-foreground">Â∞ÜÂæÆ‰ø°ÂÖ¨‰ºóÂè∑ÊñáÁ´†ËΩ¨Êç¢‰∏∫MarkdownÊ†ºÂºèÔºåÂõæÁâáËá™Âä®‰ΩøÁî®‰ª£ÁêÜÈìæÊé•</p>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* ËæìÂÖ•Âå∫Âüü */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center gap-2">
                <FileText className="w-5 h-5" />
                ËæìÂÖ•ÂÜÖÂÆπ
              </CardTitle>
              <CardDescription>ËæìÂÖ•ÂæÆ‰ø°ÂÖ¨‰ºóÂè∑ÊñáÁ´†ÈìæÊé•ÊàñÁõ¥Êé•Á≤òË¥¥HTMLÂÜÖÂÆπ</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
              <Tabs defaultValue="url" className="w-full">
                <TabsList className="grid w-full grid-cols-2">
                  <TabsTrigger value="url" className="flex items-center gap-2">
                    <Link className="w-4 h-4" />
                    URLÈìæÊé•
                  </TabsTrigger>
                  <TabsTrigger value="html" className="flex items-center gap-2">
                    <FileText className="w-4 h-4" />
                    HTMLÂÜÖÂÆπ
                  </TabsTrigger>
                </TabsList>

                <TabsContent value="url" className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="url">ÂæÆ‰ø°ÂÖ¨‰ºóÂè∑ÊñáÁ´†ÈìæÊé•</Label>
                    <Input
                      id="url"
                      placeholder="https://mp.weixin.qq.com/s/..."
                      value={inputUrl}
                      onChange={(e) => setInputUrl(e.target.value)}
                    />
                  </div>
                  <Button onClick={fetchFromUrl} disabled={isLoading} className="w-full">
                    {isLoading ? "Ëé∑Âèñ‰∏≠..." : "Ëé∑ÂèñÂπ∂ËΩ¨Êç¢ÊñáÁ´†"}
                  </Button>
                  <p className="text-sm text-muted-foreground">ÊîØÊåÅÁõ¥Êé•‰ªéÂæÆ‰ø°ÂÖ¨‰ºóÂè∑ÈìæÊé•Ëé∑ÂèñÊñáÁ´†ÂÜÖÂÆπÂπ∂Ëá™Âä®ËΩ¨Êç¢</p>
                </TabsContent>

                <TabsContent value="html" className="space-y-4">
                  <div className="space-y-2">
                    <Label htmlFor="html">HTMLÂÜÖÂÆπ</Label>
                    <Textarea
                      id="html"
                      placeholder="Á≤òË¥¥ÂæÆ‰ø°ÂÖ¨‰ºóÂè∑ÊñáÁ´†ÁöÑHTMLÂÜÖÂÆπ..."
                      value={inputHtml}
                      onChange={(e) => setInputHtml(e.target.value)}
                      rows={12}
                      className="font-mono text-sm"
                    />
                  </div>
                  <Button onClick={convertHtml} disabled={isLoading} className="w-full">
                    {isLoading ? "ËΩ¨Êç¢‰∏≠..." : "ËΩ¨Êç¢‰∏∫Markdown"}
                  </Button>
                </TabsContent>
              </Tabs>
            </CardContent>
          </Card>

          {/* ËæìÂá∫Âå∫Âüü */}
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center justify-between">
                <span className="flex items-center gap-2">
                  <FileText className="w-5 h-5" />
                  MarkdownËæìÂá∫
                </span>
                {markdown && (
                  <div className="flex gap-2">
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={copyToClipboard}
                      className="flex items-center gap-2 bg-transparent"
                    >
                      <Copy className="w-4 h-4" />
                      Â§çÂà∂
                    </Button>
                    <Button
                      variant="outline"
                      size="sm"
                      onClick={downloadMarkdown}
                      className="flex items-center gap-2 bg-transparent"
                    >
                      <Download className="w-4 h-4" />
                      ‰∏ãËΩΩ
                    </Button>
                  </div>
                )}
              </CardTitle>
              <CardDescription>ËΩ¨Êç¢ÂêéÁöÑMarkdownÊ†ºÂºèÂÜÖÂÆπÔºåÂõæÁâáÂ∑≤‰ΩøÁî®‰ª£ÁêÜÈìæÊé•ÔºåÈü≥È¢ë/ËßÜÈ¢ëËΩ¨Êç¢‰∏∫ÊñáÊú¨Ê†áËÆ∞</CardDescription>
            </CardHeader>
            <CardContent>
              {markdown ? (
                <Textarea value={markdown} readOnly rows={20} className="font-mono text-sm" />
              ) : (
                <div className="h-80 flex items-center justify-center text-muted-foreground border border-dashed rounded-md">
                  ËΩ¨Êç¢ÂêéÁöÑMarkdownÂÜÖÂÆπÂ∞ÜÊòæÁ§∫Âú®ËøôÈáå
                </div>
              )}
            </CardContent>
          </Card>
        </div>

        {/* ‰ΩøÁî®ËØ¥Êòé */}
        <Card>
          <CardHeader>
            <CardTitle>‰ΩøÁî®ËØ¥Êòé</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <h4 className="font-semibold">ÊñπÊ≥ï‰∏ÄÔºöURLÈìæÊé•ËΩ¨Êç¢ÔºàÊé®ËçêÔºâ</h4>
                <ol className="text-sm text-muted-foreground space-y-1 list-decimal list-inside">
                  <li>Â§çÂà∂ÂæÆ‰ø°ÂÖ¨‰ºóÂè∑ÊñáÁ´†ÈìæÊé•</li>
                  <li>Á≤òË¥¥Âà∞URLËæìÂÖ•Ê°Ü‰∏≠</li>
                  <li>ÁÇπÂáª"Ëé∑ÂèñÂπ∂ËΩ¨Êç¢ÊñáÁ´†"ÊåâÈíÆ</li>
                  <li>Á≠âÂæÖËá™Âä®Ëé∑ÂèñÂπ∂ËΩ¨Êç¢ÂÆåÊàê</li>
                </ol>
              </div>
              <div className="space-y-2">
                <h4 className="font-semibold">ÊñπÊ≥ï‰∫åÔºöHTMLÂÜÖÂÆπËΩ¨Êç¢</h4>
                <ol className="text-sm text-muted-foreground space-y-1 list-decimal list-inside">
                  <li>ÊâìÂºÄÂæÆ‰ø°ÂÖ¨‰ºóÂè∑ÊñáÁ´†È°µÈù¢</li>
                  <li>ÊåâF12ÊâìÂºÄÂºÄÂèëËÄÖÂ∑•ÂÖ∑</li>
                  <li>ÊâæÂà∞ÊñáÁ´†ÂÜÖÂÆπÁöÑHTML‰ª£Á†Å</li>
                  <li>Â§çÂà∂HTMLÂÜÖÂÆπÂà∞ÊñáÊú¨Ê°Ü</li>
                  <li>ÁÇπÂáª"ËΩ¨Êç¢‰∏∫Markdown"ÊåâÈíÆ</li>
                </ol>
              </div>
            </div>
            <div className="space-y-2">
              <h4 className="font-semibold">ÂäüËÉΩÁâπÁÇπ</h4>
              <ul className="text-sm text-muted-foreground space-y-1 list-disc list-inside">
                <li>ÊîØÊåÅÁõ¥Êé•‰ªéÂæÆ‰ø°ÂÖ¨‰ºóÂè∑ÈìæÊé•Ëé∑ÂèñÊñáÁ´†ÂÜÖÂÆπ</li>
                <li>Ëá™Âä®Ê∑ªÂä†ÂéüÊñáÈìæÊé•ÂíåÊ†áÈ¢òÔºàURLÊ®°ÂºèÔºâ</li>
                <li>Ëá™Âä®ËΩ¨Êç¢Ê†áÈ¢ò„ÄÅÊÆµËêΩ„ÄÅÂàóË°®Á≠âÊ†ºÂºè</li>
                <li>ÂõæÁâáÈìæÊé•Ëá™Âä®‰ΩøÁî®‰ª£ÁêÜÔºåÁ°Æ‰øùÊòæÁ§∫Ê≠£Â∏∏</li>
                <li>Èü≥È¢ë/ËßÜÈ¢ëËΩ¨Êç¢‰∏∫ÊñáÊú¨Ê†áËÆ∞ÂíåÊí≠ÊîæÈìæÊé•</li>
                <li>‰øùÁïôÊñáÁ´†ÁöÑÂü∫Êú¨ÁªìÊûÑÂíåÊ†ºÂºè</li>
                <li>ÊîØÊåÅÂ§çÂà∂Âà∞Ââ™Ë¥¥ÊùøÂíå‰∏ãËΩΩÊñá‰ª∂</li>
                <li>ÊîØÊåÅÁ≤ó‰Ωì„ÄÅÊñú‰Ωì„ÄÅÈìæÊé•Á≠âÊ†∑Âºè</li>
                <li>ÊîØÊåÅË°®Ê†ºÂíåÊ∞¥Âπ≥ÂàÜÂâ≤Á∫øÁöÑËΩ¨Êç¢</li>
              </ul>
            </div>
          </CardContent>
        </Card>
      </div>
      <Toaster />
    </div>
  )
}
